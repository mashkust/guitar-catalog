{"ast":null,"code":"import React, { useContext } from 'react';\nvar UntabbableContext = React.createContext(false);\n/**\n * A wrapper that marks a section of the component tree as unreachable via the\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\n * single element child. By itself it does nothing, but descendants using the\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\n * ancestor.\n *\n * If you need to toggle tabbability back on, set the `active` prop to false.\n * This is preferable to conditionally inserting the Untabbable parent since it\n * keeps the component tree structure the same, avoiding remounts.\n */\n\nfunction Untabbable(_ref) {\n  let {\n    // Whether this Untabbable is actually active, overriding the output of\n    // `useTabIndex`.\n    active = true,\n    // Context provider children.\n    children,\n    // Whether this Untabbable should ignore ancestor Untabbable state. This is\n    // rarely what you want, unless you are setting up something with modal\n    // elements. In that case, you may want all elements behind the modal to\n    // become untabbable, but the modal element is likely to have that same\n    // Untabbable context as its ancestor (since context is preserved across\n    // portals). Thus, the content of the modal component itself should be wrapped\n    // in an Untabbable with the `reset` prop.\n    reset = false\n  } = _ref;\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\n  // shorthand like `active={object}`, `active={array.length}`, etc.\n\n  const value = Boolean(reset ? active : active || anyParentActive);\n  return React.createElement(UntabbableContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction useTabIndex(tabIndex) {\n  const isUntabbable = useContext(UntabbableContext);\n  return isUntabbable ? -1 : tabIndex;\n}\n\nexport { Untabbable, UntabbableContext, useTabIndex };","map":{"version":3,"sources":["/Users/mashkust/react-starter-pack-main/node_modules/react-tabindex/dist/index.esm.js"],"names":["React","useContext","UntabbableContext","createContext","Untabbable","active","children","reset","anyParentActive","value","Boolean","createElement","Provider","useTabIndex","tabIndex","isUntabbable"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,UAAhB,QAAkC,OAAlC;AAEA,IAAIC,iBAAiB,GAAGF,KAAK,CAACG,aAAN,CAAoB,KAApB,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,UAAT,OAcG;AAAA,MAdiB;AAClB;AACA;AACAC,IAAAA,MAAM,GAAG,IAHS;AAIlB;AACAC,IAAAA,QALkB;AAMlB;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,IAAAA,KAAK,GAAG;AAbU,GAcjB;AACD,QAAMC,eAAe,GAAGP,UAAU,CAACC,iBAAD,CAAlC,CADC,CACsD;AACvD;;AAEA,QAAMO,KAAK,GAAGC,OAAO,CAACH,KAAK,GAAGF,MAAH,GAAYA,MAAM,IAAIG,eAA5B,CAArB;AACA,SAAOR,KAAK,CAACW,aAAN,CAAoBT,iBAAiB,CAACU,QAAtC,EAAgD;AACrDH,IAAAA,KAAK,EAAEA;AAD8C,GAAhD,EAEJH,QAFI,CAAP;AAGD;;AAED,SAASO,WAAT,CAAqBC,QAArB,EAA+B;AAC7B,QAAMC,YAAY,GAAGd,UAAU,CAACC,iBAAD,CAA/B;AACA,SAAOa,YAAY,GAAG,CAAC,CAAJ,GAAQD,QAA3B;AACD;;AAED,SAASV,UAAT,EAAqBF,iBAArB,EAAwCW,WAAxC","sourcesContent":["import React, { useContext } from 'react';\n\nvar UntabbableContext = React.createContext(false);\n\n/**\n * A wrapper that marks a section of the component tree as unreachable via the\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\n * single element child. By itself it does nothing, but descendants using the\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\n * ancestor.\n *\n * If you need to toggle tabbability back on, set the `active` prop to false.\n * This is preferable to conditionally inserting the Untabbable parent since it\n * keeps the component tree structure the same, avoiding remounts.\n */\n\nfunction Untabbable({\n  // Whether this Untabbable is actually active, overriding the output of\n  // `useTabIndex`.\n  active = true,\n  // Context provider children.\n  children,\n  // Whether this Untabbable should ignore ancestor Untabbable state. This is\n  // rarely what you want, unless you are setting up something with modal\n  // elements. In that case, you may want all elements behind the modal to\n  // become untabbable, but the modal element is likely to have that same\n  // Untabbable context as its ancestor (since context is preserved across\n  // portals). Thus, the content of the modal component itself should be wrapped\n  // in an Untabbable with the `reset` prop.\n  reset = false\n}) {\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\n  // shorthand like `active={object}`, `active={array.length}`, etc.\n\n  const value = Boolean(reset ? active : active || anyParentActive);\n  return React.createElement(UntabbableContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction useTabIndex(tabIndex) {\n  const isUntabbable = useContext(UntabbableContext);\n  return isUntabbable ? -1 : tabIndex;\n}\n\nexport { Untabbable, UntabbableContext, useTabIndex };\n"]},"metadata":{},"sourceType":"module"}